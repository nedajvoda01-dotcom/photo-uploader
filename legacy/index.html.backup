<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Загрузка фото на Яндекс.Диск</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 820px; margin: 40px auto; padding: 0 16px; }
    h1 { margin: 0 0 8px; }
    .muted { color: #9aa0a6; font-size: 14px; line-height: 1.4; }
    .card { border: 1px solid #303134; border-radius: 14px; padding: 16px; background: #0f1113; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    input[type="text"] { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #303134; background: #111; color: #e8eaed; }
    input[type="file"] { width: 100%; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #303134; background: #1f1f1f; color: #e8eaed; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .preview { display:flex; gap: 16px; align-items: flex-start; }
    .thumb { width: 180px; height: 180px; border-radius: 12px; border: 1px solid #303134; background:#111; object-fit: cover; display:none; }
    .log { margin-top: 12px; white-space: pre-wrap; background: #0b0c0e; border: 1px solid #303134; border-radius: 12px; padding: 12px; overflow: auto; }
    .ok { color: #34a853; }
    .bad { color: #ea4335; }
    .warn { color: #fbbc05; }
    .small { font-size: 12px; }
    .spacer { height: 10px; }
    .hint { border-left: 3px solid #303134; padding-left: 10px; }
  </style>
</head>
<body>
  <h1>Upload → Яндекс.Диск</h1>
  <p class="muted">
    Этот фронт работает через твой Apps Script backend. Файл отправляется в формате base64, а backend грузит на Яндекс.Диск.
  </p>

  <div class="card">
    <div class="preview">
      <img id="thumb" class="thumb" alt="preview" />
      <div style="flex:1; min-width: 260px;">
        <div class="row">
          <input id="file" type="file" accept="image/*" />
        </div>

        <div class="spacer"></div>

        <div class="muted small">Папка на Диске (начинай с <code>disk:/</code>)</div>
        <input id="folder" type="text" value="disk:/Загрузки" />

        <div class="spacer"></div>

        <div class="muted small">Переименовать файл (опционально)</div>
        <input id="name" type="text" placeholder="оставь пустым — будет имя файла" />

        <div class="spacer"></div>

        <div class="row">
          <button id="btn">Upload</button>
          <button id="btnClear" type="button">Clear</button>
          <label class="muted small"><input id="overwrite" type="checkbox" checked /> overwrite (на бэке)</label>
        </div>

        <div class="spacer"></div>

        <div class="hint muted small">
          Важно: если ты оставишь <code>API_KEY</code> внутри этого файла и репозиторий публичный — ключ увидят все.
          Для MVP ок, для прод — вынеси авторизацию на бэк.
        </div>
      </div>
    </div>

    <div class="spacer"></div>
    <div id="status" class="muted small">Готов.</div>
    <div id="log" class="log muted">{}</div>
  </div>

  <script>
    // === НАСТРОЙКА (вставь свои значения) ===
    // ⚠️ LEGACY BACKUP - НЕ ИСПОЛЬЗОВАТЬ НАПРЯМУЮ!
    // Реальные секреты удалены. См. основной index.html
    const BACKEND_URL = "PASTE_YOUR_GOOGLE_APPS_SCRIPT_URL_HERE";
    const API_KEY = "PASTE_YOUR_API_KEY_HERE"; // если не нужен — оставь пустым ""
    // =======================================

    const elFile = document.getElementById("file");
    const elFolder = document.getElementById("folder");
    const elName = document.getElementById("name");
    const elBtn = document.getElementById("btn");
    const elBtnClear = document.getElementById("btnClear");
    const elLog = document.getElementById("log");
    const elStatus = document.getElementById("status");
    const elThumb = document.getElementById("thumb");
    const elOverwrite = document.getElementById("overwrite");

    function setStatus(text, cls = "") {
      elStatus.className = "muted small " + cls;
      elStatus.textContent = text;
    }

    function log(obj, cls = "") {
      elLog.className = "log muted " + cls;
      elLog.textContent = (typeof obj === "string") ? obj : JSON.stringify(obj, null, 2);
    }

    function sanitizeFolder(folder) {
      folder = String(folder || "").trim();
      if (!folder) return "disk:/Загрузки";
      // normalize: allow disk:/... with or without trailing /
      if (!folder.startsWith("disk:/")) return null;
      return folder.replace(/\/+$/, "");
    }

    function safeName(name) {
      name = String(name || "").trim();
      if (!name) return "";
      // prevent path traversal in client too (server also sanitizes)
      return name.replace(/[\/\\]/g, "_").slice(0, 180);
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => {
          const res = String(r.result || "");
          const idx = res.indexOf("base64,");
          if (idx === -1) return reject(new Error("base64 parse failed"));
          resolve(res.slice(idx + 7));
        };
        r.onerror = reject;
        r.readAsDataURL(file);
      });
    }

    function showPreview(file) {
      if (!file || !file.type.startsWith("image/")) {
        elThumb.style.display = "none";
        elThumb.src = "";
        return;
      }
      const url = URL.createObjectURL(file);
      elThumb.src = url;
      elThumb.style.display = "block";
      // revoke later
      setTimeout(() => URL.revokeObjectURL(url), 60_000);
    }

    elFile.addEventListener("change", () => {
      const f = elFile.files && elFile.files[0];
      showPreview(f);
      if (f && !elName.value.trim()) {
        // не автоподставляем имя в поле, но можно подсказать
        setStatus(`Выбран файл: ${f.name} (${Math.round(f.size/1024)} KB)`);
      }
    });

    elBtnClear.addEventListener("click", () => {
      elFile.value = "";
      elName.value = "";
      elFolder.value = "disk:/Загрузки";
      elThumb.style.display = "none";
      elThumb.src = "";
      setStatus("Готов.");
      log({});
    });

    async function upload() {
      const file = elFile.files && elFile.files[0];
      if (!file) {
        setStatus("Выбери файл.", "warn");
        return;
      }

      const folder = sanitizeFolder(elFolder.value);
      if (!folder) {
        setStatus("Папка должна начинаться с disk:/", "bad");
        return;
      }

      const customName = safeName(elName.value);
      const filename = customName || file.name;

      elBtn.disabled = true;
      setStatus("Кодирую файл (base64)...");

      try {
        const contentBase64 = await fileToBase64(file);

        const payload = {
          filename,
          mime: file.type || "application/octet-stream",
          contentBase64,
          folder
          // overwrite управляется на бэке (в нашем GAS оно всегда overwrite=true),
          // чекбокс оставлен для будущей доработки.
        };

        const url = API_KEY ? `${BACKEND_URL}?key=${encodeURIComponent(API_KEY)}` : BACKEND_URL;

        setStatus("Отправляю на backend...");
        const resp = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        const text = await resp.text();
        let data;
        try { data = JSON.parse(text); } catch { data = { raw: text }; }

        if (data && data.ok) {
          setStatus("Готово: загружено на Яндекс.Диск.", "ok");
          log(data, "ok");
        } else {
          setStatus("Ошибка загрузки (смотри лог).", "bad");
          log(data, "bad");
        }

      } catch (e) {
        setStatus("Ошибка: " + (e && e.message ? e.message : String(e)), "bad");
        log(String(e && e.stack ? e.stack : e), "bad");
      } finally {
        elBtn.disabled = false;
      }
    }

    elBtn.addEventListener("click", upload);

    // быстрый self-check
    (async () => {
      try {
        const resp = await fetch(BACKEND_URL, { method: "GET" });
        const text = await resp.text();
        // если это JSON ok — хорошо
        try {
          const j = JSON.parse(text);
          if (j && j.ok) setStatus("Backend OK (GET).");
          else setStatus("Backend ответил, но не ok.", "warn");
        } catch {
          setStatus("Backend ответил (не JSON).", "warn");
        }
      } catch {
        setStatus("Backend недоступен (проверь URL / доступ).", "bad");
      }
      log({});
    })();
  </script>
</body>
</html>
